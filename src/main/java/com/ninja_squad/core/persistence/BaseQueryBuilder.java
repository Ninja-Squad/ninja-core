package com.ninja_squad.core.persistence;

import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Nonnull;

import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;


/**
 * Base class for {@link com.ninja_squad.core.persistence.jpa.JpqlQueryBuilder} and
 * {@link com.ninja_squad.core.persistence.hibernate.HqlQueryBuilder}
 *
 * @param <Q> the type of query generated by this builder.
 * @author JB
 */
public class BaseQueryBuilder<Q> {

    private final boolean distinct;
    private final List<String> selectClauses = Lists.newArrayList();
    private final List<String> fromClauses = Lists.newArrayList();
    private final List<String> whereClauses = Lists.newArrayList();
    private final List<String> groupByClauses = Lists.newArrayList();
    private final List<String> havingClauses = Lists.newArrayList();
    private final List<String> orderByClauses = Lists.newArrayList();
    private final Map<String, ParameterBinder<Q>> parameters = new HashMap<String, ParameterBinder<Q>>();

    /**
     * Constructor
     * @param distinct indicates if the query is a <code>select...</code> or a
     * <code>select distinct...</code>
     */
    protected BaseQueryBuilder(boolean distinct) {
        this.distinct = distinct;
    }

    /**
     * Adds a clause element to the <em>select</em> clause. The elements are automatically separated by commas.
     * @param clause the clause element to add.
     */
    protected final void addSelect(@Nonnull String clause) {
        Preconditions.checkNotNull(clause, "clause may not be null");
        selectClauses.add(clause);
    }

    /**
     * Adds a clause element to the <em>from</em> clause. The elements are automatically separated by spaces.
     * @param clause the clause element to add.
     */
    protected final void addFrom(@Nonnull String clause) {
        Preconditions.checkNotNull(clause, "clause may not be null");
        fromClauses.add(clause);
    }

    /**
     * Adds a clause element to the <em>where</em> clause. The elements are automatically separated by <code>and</code>.
     * To add elements separated by <code>or</code>, use a disjunction.
     * @param clause the clause element to add.
     */
    protected final void addWhere(@Nonnull String clause) {
        Preconditions.checkNotNull(clause, "clause may not be null");
        whereClauses.add(clause);
    }

    /**
     * Adds a clause element to the <em>group by</em> clause. The elements are automatically separated by commas.
     * @param clause the clause element to add.
     */
    protected final void addGroupBy(@Nonnull String clause) {
        Preconditions.checkNotNull(clause, "clause may not be null");
        groupByClauses.add(clause);
    }

    /**
     * Adds a clause element to the <em>having</em> clause. The elements are automatically
     * separated by <code>and</code>.
     * To add elements separated by <code>or</code>, use a disjunction.
     * @param clause the clause element to add.
     */
    protected final void addHaving(@Nonnull String clause) {
        Preconditions.checkNotNull(clause, "clause may not be null");
        havingClauses.add(clause);
    }

    /**
     * Adds a clause element to the <em>order by</em> clause. The elements are automatically
     * separated by commas.
     * @param clause the clause element to add.
     */
    protected final void addOrderBy(@Nonnull String clause) {
        Preconditions.checkNotNull(clause, "clause may not be null");
        orderByClauses.add(clause);
    }

    /**
     * Sets a parameter binder that will be used when the query will be created. Note that the same
     * parameter name may be set several times. The last set value wins.
     * @param name the name of the parameter (without the <code>:</code> prefix)
     * @param binder the binder of the parameter
     */
    protected final void setParameterBinder(@Nonnull String name, @Nonnull ParameterBinder<Q> binder) {
        Preconditions.checkNotNull(name, "name may not be null");
        Preconditions.checkNotNull(binder, "binder may not be null");
        parameters.put(name, binder);
    }

    /**
     * Creates a conjunction (i.e. <code>A and B and C</code>) from the individual given clauses
     * @param clauses the clauses to join in a conjunction (i.e. A, B, C)
     * @return the clauses, joined with <code>and</code> and enclosed in parentheses.
     * @throws IllegalArgumentException if the clauses collection is empty
     */
    public final String conjunction(@Nonnull Collection<String> clauses) {
        Preconditions.checkNotNull(clauses, "clauses may not be null");
        Preconditions.checkArgument(!clauses.isEmpty(), "clauses may not be empty");
        return "(" + Joiner.on(" and ").join(clauses) + ")";
    }

    /**
     * Creates a conjunction (i.e. <code>A and B and C</code>) from the individual given clauses
     * @param firstClause the first clause to join in a conjunction
     * @param secondClause the first clause to join in a conjunction
     * @param otherClauses the other clauses to join in a conjunction
     * @return the clauses, joined with <code>and</code> and enclosed in parentheses.
     * @throws IllegalArgumentException if the clauses collection is empty
     */
    public final String conjunction(@Nonnull String firstClause, @Nonnull String secondClause, String... otherClauses) {
        Preconditions.checkNotNull(firstClause, "firstClause may not be null");
        Preconditions.checkNotNull(secondClause, "secondClause may not be null");
        Preconditions.checkNotNull(otherClauses, "other clauses may not be null");
        for (String clause : otherClauses) {
            Preconditions.checkNotNull(clause, "other clauses may not be null");
        }

        return "(" + Joiner.on(" and ").join(firstClause, secondClause, (Object[]) otherClauses) + ")";
    }

    /**
     * Creates a disjunction (i.e. <code>A or B or C</code>) from the individual given clauses
     * @param clauses the clauses to join in a disjunction (i.e. A, B, C)
     * @return the clauses, joined with <code>or</code> and enclosed in parentheses.
     * @throws IllegalArgumentException if the clauses collection is empty
     */
    public final String disjunction(@Nonnull Collection<String> clauses) {
        Preconditions.checkNotNull(clauses, "clauses may not be null");
        Preconditions.checkArgument(!clauses.isEmpty(), "clauses may not be empty");

        return "(" + Joiner.on(" or ").join(clauses) + ")";
    }

    /**
     * Creates a disjunction (i.e. <code>A or B or C</code>) from the individual given clauses
     * @param firstClause the first clause to join in a disjunction
     * @param secondClause the first clause to join in a disjunction
     * @param otherClauses the other clauses to join in a disjunction
     * @return the clauses, joined with <code>or</code> and enclosed in parentheses.
     * @throws IllegalArgumentException if the clauses collection is empty
     */
    public final String disjunction(@Nonnull String firstClause, @Nonnull String secondClause, String... otherClauses) {
        Preconditions.checkNotNull(firstClause, "firstClause may not be null");
        Preconditions.checkNotNull(secondClause, "secondClause may not be null");
        Preconditions.checkNotNull(otherClauses, "other clauses may not be null");
        for (String clause : otherClauses) {
            Preconditions.checkNotNull(clause, "other clauses may not be null");
        }

        return "(" + Joiner.on(" or ").join(firstClause, secondClause, (Object[]) otherClauses) + ")";
    }

    /**
     * Creates the query string
     * @return the generated query string
     */
    protected final String createQueryString() {
        Preconditions.checkState(!selectClauses.isEmpty(), "There is no select clause. This is not allowed");
        Preconditions.checkState(!fromClauses.isEmpty(), "There is no from clause. This is not allowed");

        StringBuilder out = new StringBuilder();
        out.append("select ");
        if (distinct) {
            out.append("distinct ");
        }
        Joiner.on(", ").appendTo(out, selectClauses);

        out.append(" from ");
        Joiner.on(" ").appendTo(out, fromClauses);

        if (!whereClauses.isEmpty()) {
            out.append(" where ");
            Joiner.on(" and ").appendTo(out, whereClauses);
        }

        if (!groupByClauses.isEmpty()) {
            out.append(" group by ");
            Joiner.on(", ").appendTo(out, groupByClauses);
        }

        if (!havingClauses.isEmpty()) {
            out.append(" having ");
            Joiner.on(" and ").appendTo(out, havingClauses);
        }

        if (!orderByClauses.isEmpty()) {
            out.append(" order by ");
            Joiner.on(", ").appendTo(out, groupByClauses);
        }

        return out.toString();
    }

    /**
     * Binds all the parameters to the given query
     * @param query the query to bind the parameters to
     */
    protected final void bindParameters(Q query) {
        for (ParameterBinder<Q> binder : parameters.values()) {
            binder.bind(query);
        }
    }

    /**
     * Interface of the parameter binders
     * @param <Q> the type of the query to which the parameters are bound
     * @author JB
     */
    protected interface ParameterBinder<Q> {
        /**
         * Binds the parameter to the query
         * @param query the query
         */
        void bind(Q query);
    }
}
